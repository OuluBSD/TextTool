#include "OrgCtrl.h"

#define IMAGECLASS OrgLibImgs
#define IMAGEFILE <OrgCtrl/OrgLibImages.iml>
#include <Draw/iml_source.h>


INITBLOCK {
	using namespace TextLib;
	
	// NOTE: this order can't be changed or data breaks!
	NodeFactory::Register<UppExporterCtrl,UppExporterView>("U++ project", NODE_EXPORTER);
	NodeFactory::Register<SystemCtrl,SystemView>("System", NODE_SYSTEM);
	NodeFactory::Register<FeaturesCtrl,FeaturesView>("Features", NODE_FEATURES);
	NodeFactory::Register<FileListCtrl,FileListView>("File list", NODE_FILE_LIST);
	NodeFactory::Register<FileCtrl,FileView>("File", NODE_FILE);
	NodeFactory::Register<DebugCtrl,DebugView>("Debug", NODE_DEBUG);
	NodeFactory::Register<ProjectWizardCtrl,ProjectWizardView>("Project Wizard", NODE_WIZARD);
	
	ProjectWizardView::RegisterCategory("dummy", "Dummy values for testing only");
	ProjectWizardView::Register("/dummy 0/example0:item 0", "3 fixed options")
		.OptionFixed("A")
		.OptionFixed("B")
		.OptionFixed("C");
	ProjectWizardView::Register("/dummy 0/example0:item 1", "3 random strings")
		.OptionValueArray()
		.PromptInput("/dummy 0/example0:item 0")
		.PromptResponse("List of 3 random dummy string values");
	ProjectWizardView::Register("/dummy 0/example1:item 1", "3 characters")
		.OptionFixed("x")
		.OptionFixed("y")
		.OptionFixed("z")
		.PromptInputOptionsLocalFixed()
		.PromptInputOptions("/dummy 0/example0:item 0")
		.PromptInput("/dummy 0/example0:item 0")
		.PromptInput("/dummy 0/example0:item 1")
		.PromptInputUserText("Some random seed text")
		.PromptResponse("List of 3 random dummy boolean values");
	ProjectWizardView::Register("/dummy 1/example0:item 0", "Select 1 from 3 fixed options")
		.OptionFixed("q")
		.OptionFixed("w")
		.OptionFixed("e");
	ProjectWizardView::Register("/dummy 1/example1:item 0", "Select 1 from 3 fixed options")
		.OptionFixed("a")
		.OptionFixed("s")
		.OptionFixed("d")
		.OptionFixed("f");
	
	
	
	// Which software project to invest (games, apps, virtual instruments, etc.):
	
	//// Determine the overall budget available for the investment.
	//// Identify the target market for the software project.
	ProjectWizardView::Register("/Idea/Product:The initial idea", "The initial idea for the software project")
		.OptionUserInputText();
	
	ProjectWizardView::Register("/Idea/Product:The target market", "The target market for the software project")
		.PromptInput("/Idea/Product:The initial idea")
		.PromptResponse("List of target markets for a software projects");
	
	//// Research the current market trends and demands.
	ProjectWizardView::Register("/Idea/Product:The market trend to follow")
		.PromptInput("/Idea/Product:The initial idea")
		.PromptInput("/Idea/Product:The target market")
		.PromptResponse("List of target trends for the software projects");
	
	ProjectWizardView::Register("/Idea/Product:The market demand to fulfill")
		.PromptInput("/Idea/Product:The initial idea")
		.PromptInput("/Idea/Product:The target market")
		.PromptInput("/Idea/Product:The market trend to follow")
		.PromptResponse("List of market demands to fulfill for the software project");
	;
	
	//// Evaluate the potential profitability and return on investment.
	ProjectWizardView::Register("/Idea/Product:Profitability")
	;
	
	//// Assess the competition in the market.
	ProjectWizardView::Register("/Idea/Product:Relationship to competition");
	
	//// Gather feedback from potential users or investors.
	ProjectWizardView::Register("/Idea/Product:Target feedback from potential users or investors");
	
	//// Develop a marketing strategy for the project.
	ProjectWizardView::Register("/Idea/Product:Core marketing idea");
	
	//// Identify potential collaborators or partners.
	ProjectWizardView::Register("/Idea/Product:Potential collaborators or partners");
	
	//// Consider the target pricing for the software product.
	ProjectWizardView::Register("/Idea/Product:Target pricing");
	
	//// Consider the sales volume of the product
	ProjectWizardView::Register("/Idea/Product:Sales volume target");
	
	
	
	
	
	// Define project requirements and scope
	ProjectWizardView::Register("/Requirements", "Define project requirements and scope");
	
	//// Identify key stakeholders and project goals
	
		//Example answers for "What are the stakeholders' specific needs and goals for this project?":
		//1. Increase efficiency in data processing
		//2. Improve user experience
		//3. Ensure data security and privacy
		//4. Integrate with existing software systems
		//5. Provide a user-friendly interface
		//6. Reduce manual tasks and improve automation
		//7. Increase productivity
		//8. Stay within budget and timeline
		//9. Scalability for future growth
		//10. Improve collaboration and communication.
	ProjectWizardView::Register("/Requirements/Specific needs:Stakeholders");
	
		//Feedback from potential users or investors for the market target "Musicians - for a virtual instrument or music production software." in the market trend "Focus on user experience - there is a growing emphasis on creating user-friendly and seamless experiences in software projects.":
		//1. "The user interface is very intuitive and easy to navigate."
		//2. "I appreciate the low latency for a real-time playing experience."
		//3. "The sounds are incredibly realistic and high-quality."
		//4. "It seamlessly integrates with my current DAW."
		//5. "I love the versatility - I can use it for any genre of music."
		//6. "The customization options allow me to make the sounds unique to my preferences."
		//7. "It runs smoothly without causing any lag or crashes on my computer."
		//8. "The customer support team was very helpful and responsive to my inquiries."
		//9. "The tutorials and training resources are very helpful for beginners like me."
		//10. "There is a wide range of instruments and effects to choose from."
		//11. "I appreciate the MIDI compatibility for easy control of instruments."
		//12. "It's great that it is cross-platform compatible, so I can use it on both my laptop and desktop."
		//13. "It's reliable and I haven't experienced any technical issues so far."
		//14. "The price is reasonable and affordable for the quality of the software."
		//15. "I can easily connect my external controllers and hardware devices for a better user experience."
	ProjectWizardView::Register("/Requirements/Specific needs:Potential users or investors");
			
		//----> features, classes, data, assets
	ProjectWizardView::Register("/Requirements/Specific needs:Features");
	ProjectWizardView::Register("/Requirements/Specific needs:Assets");
	ProjectWizardView::Register("/Requirements/Specific needs:Data");
	ProjectWizardView::Register("/Requirements/Specific needs:User entry points");
	
	
	//// Gather and analyze user requirements
	
		// List of steps:
		//1. Conduct user interviews
		//2. Create user personas
		//3. Gather feedback from potential users
		//4. Analyze existing systems or processes
		//5. Identify pain points and improvement opportunities
		//6. Consider scalability and future needs
		//7. Prioritize user requirements.
	ProjectWizardView::Register("/Requirements/User experience:User interview target");
	ProjectWizardView::Register("/Requirements/User experience:User persona target");
	ProjectWizardView::Register("/Requirements/User experience:User feedback target");
	ProjectWizardView::Register("/Requirements/User experience:State-of-the-art user experience to have");
	ProjectWizardView::Register("/Requirements/User experience:The best UX features of competition to have");
	ProjectWizardView::Register("/Requirements/User experience:The most unique UX features of competition to have");
	ProjectWizardView::Register("/Requirements/User experience:The worst UX features of competition to avoid");
	ProjectWizardView::Register("/Requirements/User experience:In-game shopping");
	ProjectWizardView::Register("/Requirements/User experience:Future needs");
	ProjectWizardView::Register("/Requirements/User experience:Feature prioritization");
	
	//// Prioritize and document project features and functionalities
	
		// Example answers
		//1. Managing and importing large datasets
		//2. User authentication and access control
		//3. Data analysis and visualization
		//4. Data filtering and manipulation
		//5. Integration with external APIs
		//6. Error handling and debugging
		//7. Exporting data in different formats
		//8. Responsive design for multiple devices
		//9. Automated backups and data recovery
		//10. Secure storage of sensitive information.
		//11. Real-time updates and notifications
		//12. Customizable user preferences
		//13. Integration with social media platforms
		//14. Support for multiple languages.
		//15. User feedback and customer support.
		//16. Integration with payment processing system.
		//17. Data encryption and secure transmission.
		//18. Integration with third-party plugins or extensions.
		//19. Generation of reports and statistics.
		//20. Collaboration and sharing capabilities.
	ProjectWizardView::Register("/Requirements/Features:Functionalities");

	//// Define project scope and constraints
	
		// Example answers
		//1. Development will focus on the desktop application only.
		//2. The application will only support specific operating systems.
		//3. Features and functionalities will be limited to the agreed upon list.
		//4. The project budget is fixed and should not exceed a certain amount.
		//5. The project must be completed within a specified timeline.
		//6. The application will be accessible and usable for people with disabilities.
		//7. The project will not involve any third-party vendors or contractors.
		//8. The application will not have advertising features.
		//9. The project scope does not include multilingual support.
		//10. The application will only support a specific number of users.
	ProjectWizardView::Register("/Requirements/Constraints:Supported hardware platform");
	ProjectWizardView::Register("/Requirements/Constraints:Supported software platform");
	ProjectWizardView::Register("/Requirements/Constraints:Maximum expected user skills");
	ProjectWizardView::Register("/Requirements/Constraints:Average expected user skills");
	ProjectWizardView::Register("/Requirements/Constraints:Minimum expected user skills");
	ProjectWizardView::Register("/Requirements/Constraints:Advertisement providers");
	ProjectWizardView::Register("/Requirements/Constraints:In-game purchasing providers");
	ProjectWizardView::Register("/Requirements/Constraints:Server scalability");
	ProjectWizardView::Register("/Requirements/Constraints:Treshold between free and premium features");
	
	//// Determine project deliverables and timeline
	
		// Example answers
		//1. A fully functional desktop application with all the agreed upon features and functionalities to be delivered within 6 months.
		//2. User documentation and training materials to be provided upon completion of the project.
		//3. A final report detailing the project development process and any challenges faced.
		//4. Regular progress updates to key stakeholders every 2 weeks.
		//5. Project budget review at the end of every month.
		//6. A beta version of the application for user testing to be delivered in 4 months.
		//7. Final delivery and implementation of the application in 6 months.
	ProjectWizardView::Register("/Requirements/Deliverables:User documentation");
	ProjectWizardView::Register("/Requirements/Deliverables:Developer documentation");
	ProjectWizardView::Register("/Requirements/Deliverables:Marketing material");
	ProjectWizardView::Register("/Requirements/Deliverables:Beta release packages");
	ProjectWizardView::Register("/Requirements/Deliverables:Final release packages");
	
	//// Validate and finalize project requirements and scope.

	
	
	
	// Create a project plan and timeline
	
	//// Break down project deliverables into smaller tasks
	
		//Examples of steps
		//1. Identify the main components or modules of the project
	ProjectWizardView::Register("/Plan/Program:Main modules");
	ProjectWizardView::Register("/Plan/Program:Sub modules #1");
	ProjectWizardView::Register("/Plan/Program:Sub modules #2");
	ProjectWizardView::Register("/Plan/Program:Sub modules #3");
	ProjectWizardView::Register("/Plan/Program:Sub modules #4");
	ProjectWizardView::Register("/Plan/Program:Sub modules #5");
	ProjectWizardView::Register("/Plan/Program:Sub modules #6");
	ProjectWizardView::Register("/Plan/Program:Sub modules #7");
	ProjectWizardView::Register("/Plan/Program:Sub modules #8");
		//2. List out specific tasks for each component
	ProjectWizardView::Register("/Plan/Program:Tasks");
		//3. Determine the order and dependencies of tasks
	ProjectWizardView::Register("/Plan/Program:Order of tasks");
		//4. Break down large tasks into smaller manageable tasks
	ProjectWizardView::Register("/Plan/Program:Sub-tasks #1");
	ProjectWizardView::Register("/Plan/Program:Sub-tasks #2");
	ProjectWizardView::Register("/Plan/Program:Sub-tasks #3");
	ProjectWizardView::Register("/Plan/Program:Sub-tasks #4");
	ProjectWizardView::Register("/Plan/Program:Sub-tasks #5");
	ProjectWizardView::Register("/Plan/Program:Sub-tasks #6");
	ProjectWizardView::Register("/Plan/Program:Sub-tasks #7");
	ProjectWizardView::Register("/Plan/Program:Sub-tasks #8");
	
		//5. Consider any potential sub-tasks or sub-components
	
	//// Assign resources and team roles to each task
	//// Estimate time and effort requirements for each task
	//// Create a project timeline or schedule
	//// Identify dependencies between tasks
	ProjectWizardView::Register("/Plan/Dependencies:Dependencies between modules");
	ProjectWizardView::Register("/Plan/Dependencies:Dependencies between sub-modules");
	ProjectWizardView::Register("/Plan/Dependencies:Dependencies between tasks");
	ProjectWizardView::Register("/Plan/Dependencies:Dependencies between sub-tasks");
	
		//Examples of steps
		//1. Determine which tasks are dependent on each other
		//2. Identify any tasks that can be worked on simultaneously
		//3. Consider any external dependencies, such as third party tools or APIs
		//4. Determine any potential delays or bottlenecks caused by dependencies
		//5. Explore ways to mitigate the impact of dependencies on the project timeline
	
	//// Determine milestones and checkpoints for measuring progress
	ProjectWizardView::Register("/Plan/Progress:Milestones");
	ProjectWizardView::Register("/Plan/Progress:Checkpoints");
	ProjectWizardView::Register("/Plan/Progress:Version targets");
	
	//// Consider potential risks and contingency plans
	//// Share and review project plan with key stakeholders
	//// Make any necessary adjustments or revisions
	//// Obtain final approval from stakeholders.
	
	
	
	
	

	// Identify necessary tools and technologies
	
	//// Consider the project requirements and objectives
	
		//Examples of steps
		//1. Identify the type of software being developed (e.g. web application, mobile app, desktop application)
	ProjectWizardView::Register("/Techologies/Requirements:Type of software");
		//2. Determine the programming languages and frameworks needed
		//3. Consider data storage and manipulation needs
	ProjectWizardView::Register("/Techologies/Requirements:Type of persistent data");
		//4. Evaluate user interface design and user experience requirements
	ProjectWizardView::Register("/Techologies/Requirements:User interface library features");
		//5. Determine if any specific hardware or operating system is needed
	ProjectWizardView::Register("/Techologies/Requirements:Special hardware features");
		//6. Consider scalability and future growth needs
	ProjectWizardView::Register("/Techologies/Requirements:Cross-platform compatibility");
		//7. Identify any specific security or privacy requirements
	ProjectWizardView::Register("/Techologies/Requirements:Security protection features");
	
	//// Research and evaluate different tools and technologies
	
		//Examples of steps
		//1. Look for reviews and comparisons of popular tools and technologies
	ProjectWizardView::Register("/Techologies/Providers:Compare programming languages");
	ProjectWizardView::Register("/Techologies/Providers:Compare libraries and frameworks");
		//2. Ask for recommendations from other developers or experts in the field
	ProjectWizardView::Register("/Techologies/Providers:Expert opinions");
		//3. Attend conferences or workshops related to the project topic
		//4. Explore online communities and forums to gather insights and feedback
	ProjectWizardView::Register("/Techologies/Providers:List of software made with similar technology stack");
	
	//// Determine which tools and technologies best fit the project requirements
	ProjectWizardView::Register("/Techologies/Providers:Score of fit of programming language");
	ProjectWizardView::Register("/Techologies/Providers:Score of fit of libraries and frameworks");
	//// Consider compatibility and integration with other systems
	ProjectWizardView::Register("/Techologies/Providers:Score of compatibility and integration");
	//// Consider budget and cost of tools and technologies
	//// Obtain necessary licenses or permissions for using certain tools and technologies
	ProjectWizardView::Register("/Techologies/Providers:Score of license freedom");
	
	
	// Set up a development environment
	
	// Choose a programming language
	
	//// Consider the project requirements and objectives
	//// Research popular and well-supported programming languages
	//// Evaluate the learning curve and availability of resources for different languages
	ProjectWizardView::Register("/Technologies/Language:Programming language");
	//// Consider compatibility with necessary tools and technologies
	//// Determine if the chosen language has libraries or frameworks that can aid in development
	ProjectWizardView::Register("/Technologies/Language:Supported features");
	//// Consider the long-term maintenance and support for the chosen language
	ProjectWizardView::Register("/Technologies/Language:Required self-made supporting libaries");
	
	//// Establish coding conventions and standards
		//1. Research industry standards and best practices
		//2. Determine coding conventions and standards that align with the chosen programming language
		//3. Document and communicate these coding conventions and standards to team members
		//4. Consider tools and frameworks that can help enforce coding conventions and standards
		//5. Continuously review and update coding conventions and standards as needed.
	ProjectWizardView::Register("/Technologies/Language:Coding conventions");


	// Determine project structure and organization
	
	//// Consider the size and complexity of the project
	ProjectWizardView::Register("/Project structure/Organization:Class structure estimation");
	//// Determine if the project will be split into different modules or components
	ProjectWizardView::Register("/Project structure/Organization:Runtime module structure estimation");
	//// Decide on a file and folder structure for the project
	ProjectWizardView::Register("/Project structure/Organization:File structure estimation");
	//// Document the project structure and organization for future reference
	ProjectWizardView::Register("/Project structure/Organization:Documentation index estimation");
	//// Determine how code will be organized and managed within the project structure.
	ProjectWizardView::Register("/Project structure/Organization:Code test index estimation");


	// Declare dependencies and libraries
	ProjectWizardView::Register("/Project structure/Organization:Code dependency estimation");
	
	// Consider program architecture and design patterns
	
		//What other design patterns are related to ECS?
	ProjectWizardView::Register("/Project structure/Architecture:Entity-Component-System (ECS) usage");
	ProjectWizardView::Register("/Project structure/Architecture:Entity-Component-System (ECS) integration with external library");
		//1. Object-Oriented Design: ECS is often compared to object-oriented design, as both patterns use a composition-based approach to organizing and managing code.
	ProjectWizardView::Register("/Project structure/Architecture:Object-Oriented design features");
		//2. Composition pattern: ECS heavily relies on the composition pattern, which is a structural design pattern that allows objects to be composed of smaller, reusable components.
	ProjectWizardView::Register("/Project structure/Architecture:Composition pattern design features");
		//3. Factory pattern: ECS can be implemented with the factory pattern, where a factory class is responsible for creating and initializing entities and their associated components.
	ProjectWizardView::Register("/Project structure/Architecture:Factory pattern design features");
		//4. Observer pattern: ECS systems can be seen as observers, as they react to changes in entities and their components.
	ProjectWizardView::Register("/Project structure/Architecture:Observer pattern design features");
		//5. Command pattern: Changes or updates to components in the ECS can be seen as commands that are executed by the systems.
	ProjectWizardView::Register("/Project structure/Architecture:Command pattern design features");
		//6. Event-driven architecture: ECS can be seen as a form of an event-driven architecture, where changes in the state of entities and components trigger events that are handled by systems.
	ProjectWizardView::Register("/Project structure/Architecture:Event-driven architecture design features");
		//7. Dependency Injection: ECS can be implemented with the use of dependency injection, where the systems and components are injected into the entities at runtime.
	ProjectWizardView::Register("/Project structure/Architecture:Dependency injection design features");
	
		//List of design patterns in software development:
		//1. Creational Patterns: These patterns focus on creating objects in a flexible, scalable, and efficient manner. Examples include the Factory pattern, Singleton pattern, and Prototype pattern.
	ProjectWizardView::Register("/Implementation/Design patterns:Creational patterns");
		//2. Structural Patterns: These patterns provide ways to organize classes, objects, and interfaces to form larger structures while keeping the relationships between them flexible. Examples include the Adapter pattern, Facade pattern, and Decorator pattern.
	ProjectWizardView::Register("/Implementation/Design patterns:Structural patterns");
		//3. Behavioral Patterns: These patterns focus on the communication and interaction between objects and classes. Examples include the Observer pattern, Command pattern, and Mediator pattern.
	ProjectWizardView::Register("/Implementation/Design patterns:Behavioral patterns");
		//4. Concurrency Patterns: These patterns deal with managing and coordinating multiple tasks or threads in a distributed system. Examples include the Thread Pool pattern, Barrier pattern, and Monitor pattern.
	ProjectWizardView::Register("/Implementation/Design patterns:Concurrency patterns");
		//5. Architectural Patterns: These patterns provide high-level guidelines for designing and organizing large-scale software systems. Examples include the Model-View-Controller pattern, Layered Architecture pattern, and Microservices pattern.
	ProjectWizardView::Register("/Implementation/Design patterns:Architectural patterns");
		//6. Integration Patterns: These patterns deal with integrating multiple systems or components to work together seamlessly. Examples include the Adapter pattern, Bridge pattern, and Broker pattern.
	ProjectWizardView::Register("/Implementation/Design patterns:Integration patterns");
		//7. Big Data Patterns: These patterns focus on handling and processing large volumes of data efficiently. Examples include the MapReduce pattern, Bulk Synchronous Parallel pattern, and Pipes and Filters pattern.
	ProjectWizardView::Register("/Implementation/Design patterns:Big data patterns");
		//8. Domain-Specific Patterns: These patterns are specific to a particular domain or industry. Examples include the Blackboard pattern in artificial intelligence and the Model-View-ViewModel pattern in user interface design.
	ProjectWizardView::Register("/Implementation/Design patterns:Domain-specific patterns");
		//9. Anti-patterns: These are common mistakes or pitfalls in software design that should be avoided. Examples include the God Object anti-pattern and the Spaghetti Code anti-pattern.
	ProjectWizardView::Register("/Implementation/Design patterns:Anti-patterns");
		
		//>>>>> classes, program structure, functions
	ProjectWizardView::Register("/Implementation/Static dependencies:Module dependencies");
	ProjectWizardView::Register("/Implementation/Static dependencies:Class dependencies");
	ProjectWizardView::Register("/Implementation/Static dependencies:Data dependencies");
	ProjectWizardView::Register("/Implementation/Runtime dependencies:Program state dependencies");
	ProjectWizardView::Register("/Implementation/Runtime dependencies:Object state dependencies");
	ProjectWizardView::Register("/Implementation/Runtime dependencies:User interface state dependencies");
	ProjectWizardView::Register("/Implementation/Interface dependencies:Interface visibility dependencies");
	ProjectWizardView::Register("/Implementation/Interface dependencies:User action dependencies");
	
		//Hierarchy of the software using Entity-Component-System design pattern:
		//1. Entity: An Entity is a basic representation of an object in the game that can have various components attached to it. It serves as a container for components and does not contain any logic or behavior of its own.
	ProjectWizardView::Register("/Implementation/ECS:Entity");
		//2. Component: A Component is a modular building block that represents a specific feature or behavior of an Entity. Examples of components could include Position, Sprite, Health, and Movement. Components only hold data and do not contain any logic.
	ProjectWizardView::Register("/Implementation/ECS:Component");
		//3. System: Systems are responsible for performing specific actions or logic on Entities that have certain components. For example, a Render System would update the position of entities with a Position component and display the corresponding sprite from the Sprite component.
	ProjectWizardView::Register("/Implementation/ECS:System");
		//4. Entity-Component Manager: The Entity-Component Manager is responsible for managing all entities, components, and systems in the game. It serves as the main interface for creating, deleting, and accessing entities and their components.
	ProjectWizardView::Register("/Implementation/ECS:Entity-Component Manager");
		//5. Input System: The Input System is responsible for handling player input and updating the corresponding components, such as" a Movement component. It takes user input and translates it into actions that affect the game entities.
	ProjectWizardView::Register("/Implementation/ECS:Input System");
		//6. Collision Detection System: The Collision Detection System is responsible for detecting collisions between entities and updating the appropriate components, such as Health or Movement, of the affected entities. It checks for collisions every frame and applies changes accordingly.
	ProjectWizardView::Register("/Implementation/ECS:Collision Detection System");
		//7. AI System: The AI System is responsible for controlling the behavior of non-player entities in the game. It uses data from components, such as Position and Movement, to determine the actions of these entities.
	ProjectWizardView::Register("/Implementation/ECS:AI System");
		//8. Audio System: The Audio System is responsible for playing sound effects and background music in the game. It communicates with the components, such as Audio, of entities that require audio playback.
	ProjectWizardView::Register("/Implementation/ECS:Audio System");
		//9. Game Interface System: The Game Interface System is responsible for displaying and managing the user interface elements of the game. It works with components, such as Text and Button, to update and display relevant information to the player.
	ProjectWizardView::Register("/Implementation/ECS:Game Interface System");
		//10. Save/Load System: The Save/Load System handles saving and loading game progress and data. It communicates with components, such as SaveData and LoadData, to store and retrieve information about the game state.
	ProjectWizardView::Register("/Implementation/ECS:Save & Load System");
		//11. Event System: The Event System handles events and notifications within the game. Components can subscribe to events and be notified when they occur. It allows for communication and interaction between different parts of the game without tight coupling.
	ProjectWizardView::Register("/Implementation/ECS:Event System");
		//12. Physics System: The Physics System is responsible for simulating physical interactions between objects in the game. It works with components, such as Rigidbody, to apply forces, calculate collisions, and update positions and velocities of entities.
	ProjectWizardView::Register("/Implementation/ECS:Physics System");
		//13. Animation System: The Animation System handles the animation of entities in the game. It updates the states of components, such as Animation, based on the game logic and input from other systems.
	ProjectWizardView::Register("/Implementation/ECS:Animation System");
		//14. Resource Manager: The Resource Manager is responsible for loading and managing game assets, such as graphics, sounds, and music. It works with components that require these resources and ensures they are loaded and available when needed.
	ProjectWizardView::Register("/Implementation/ECS:Resource Manager");
		//15. Debug System: The Debug System is responsible for displaying debug information while the game is running, such as the state of entities and components. It works with other systems to collect and display relevant data for debugging purposes.
	ProjectWizardView::Register("/Implementation/ECS:Debug System");
	
	ProjectWizardView::Register("/Implementation/ECS:Graphics System");
	ProjectWizardView::Register("/Implementation/ECS:Network System");
		
		//>>>>> classes, program structure, functions

	// Consider performance and efficiency
	
	
	
	// Consider user interface design and user experience
	
	//// User requirements and expectations
	ProjectWizardView::Register("/Implementation/User interface:Requirements");
	ProjectWizardView::Register("/Implementation/User interface:Expectations");
	//// Platform or device compatibility
	ProjectWizardView::Register("/Implementation/User interface:Platform compatibility");
	//// Design standards and guidelines
	ProjectWizardView::Register("/Implementation/User interface:Design standards and guidelines");
	//// User interaction and navigation needs
	ProjectWizardView::Register("/Implementation/User interface:User interaction and navigation needs");
	//// Visual aesthetics and branding
	ProjectWizardView::Register("/Implementation/User interface:Visual aesthetics and branding");
	//// Integration with other system components
	ProjectWizardView::Register("/Implementation/User interface:Integration with other system components");
	//// Accessibility and usability considerations
	ProjectWizardView::Register("/Implementation/User interface:Accessibility and usability considerations");
	//// Time and budget constraints
	//// Potential for future updates and changes
	//// Testing and feedback from user experience testing.
	ProjectWizardView::Register("/Implementation/User interface:Testing and feedback from user experience testing");



	// Consider data structures, classes, and functions needed
	ProjectWizardView::Register("/Implementation/Code:Database structure");
	ProjectWizardView::Register("/Implementation/Code:Class structure");
	ProjectWizardView::Register("/Implementation/Code:Class fields");
	ProjectWizardView::Register("/Implementation/Code:Class methods");
	ProjectWizardView::Register("/Implementation/Code:Static functions");
	ProjectWizardView::Register("/Implementation/Code:Static variables");
	ProjectWizardView::Register("/Implementation/Code:Scope variables"); // functions, methods, etc.
	
		//List of things to consider before deciding game structures, classes and functions:
		//1. Game genre and gameplay mechanics
		//2. Target audience and their preferences
		//3. Design and visual style
		//4. Compatibility with platforms or devices
		//5. Performance and optimization needs
		//6. Integration with other game systems
		//7. Resource management and asset loading
	ProjectWizardView::Register("/Implementation/Resources:Images");
	ProjectWizardView::Register("/Implementation/Resources:Textures");
	ProjectWizardView::Register("/Implementation/Resources:2D Models");
	ProjectWizardView::Register("/Implementation/Resources:3D Models");
	ProjectWizardView::Register("/Implementation/Resources:Audio");
	ProjectWizardView::Register("/Implementation/Resources:Text");
	ProjectWizardView::Register("/Implementation/Resources:Script");
		//8. User interface and user experience design
		//9. Multiplayer or online capabilities
		//10. Potential for future updates and expansions.

	
	// Consider data security and privacy
	// Consider integration with other systems or platforms
	// Consider maintenance and future updates
	// Consider error handling and debugging strategies
	
	// Create source code file(s).

		//Project files of "Visual Studio Code":
		//1. .vscode folder - contains project-specific settings and configurations for Visual Studio Code
		//2. .gitignore - stores a list of files and folders to be ignored by Git
		//3. .editorconfig - used to maintain consistent coding styles across different editors
		//4. package.json - contains information about the project dependencies
		//5. launch.json - defines configurations for debugging the project
		//6. tasks.json - used to define tasks and scripts to be executed in the project
		//7. settings.json - contains user preferences and settings for Visual Studio Code
		//8. node_modules - folder that contains the project dependencies installed using Node Package Manager
		//9. src folder - typically contains the source code files for the project
		//10. .git folder - contains Git repository information.
	ProjectWizardView::Register("/Implementation/Files:Project files");
		
		//Solution files of "Visual studio code":
		//1. .sln file - contains solution-level information and references to project files
		//2. .vcxproj file - contains project-specific configurations and settings in XML format
		//3. .vcxproj.filters file - stores information about project files and their filters within the solution explorer
		//4. .suo file - contains user-specific solution settings
		//5. .user file - stores user-specific project settings and configurations
		//6. .vssscc file - used by Team Foundation Server for source control operations
		//7. .vspscc file - used by Visual Studio for source control operations
		//8. .nuget folder - contains information about project dependencies installed using NuGet package manager
		//9. obj folder - contains temporary object files used during the build process
		//10. bin folder - contains the final compiled output of the project.
	ProjectWizardView::Register("/Implementation/Files:Solution files");
		
		//Compiled/product/export files of "Visual studio code" in platform "Desktop: Windows PC":
		//1. .exe file - executable file that can be run on the Windows operating system
		//2. .dll file - dynamic link library that contains reusable code and can be loaded and executed by programs
		//3. .pdb file - program database file used for debugging purposes
		//4. .lib file - library file that contains functions and data for use by other programs
		//5. .obj file - object file that has been compiled from source code but not yet linked
		//6. .map file - map file that shows the memory layout of the compiled program
		//7. .res file - resource file that contains non-textual data used by the program
		//8. .manifest file - contains information about the program's dependencies and compatibility
		//9. .appx file - application package file used for Windows apps
		//10. .ico file - icon file used for the program's icon in the Windows operating system.
	ProjectWizardView::Register("/Implementation/Files:Export files");
	
}
